package network

import (
	"flag"
	"fmt"
	"network/bcast"
	"network/localip"
	"network/peers"
	"strconv"
	"time"
	"global"
	"queue"
	//"msghandler"
)

const (
	master_port = 20079
	slave_port  = 20179
)

var Local_ip int
var Is_master bool
var Single_mode bool

type IP string

var Online_elev[3] int

var Num_elev_online int

type Master_msg struct {
	Address IP
	Global_list [global.NUM_GLOBAL_ORDERS]queue.Order
}

type Slave_msg struct {
	Address IP
	Internal_list [global.NUM_INTERNAL_ORDERS]queue.Order
	External_list [global.NUM_GLOBAL_ORDERS]queue.Order
	Elevator_info queue.Elev_info
}

func Choose_master() {
	ip_adresses := Online_elev
	highest_ip := 0
	Num_elev_online = 0

	for i := 0; i < 2; i++ {
		if ip_adresses[i] != -1 {
			Num_elev_online = Num_elev_online +1
		}
		if ip_adresses[i] > highest_ip {
			highest_ip = ip_adresses[i]
		}
	}
	if Local_ip == highest_ip {
		fmt.Println("I am the master.")
		Is_master = true
	}
	if highest_ip == 0{
		fmt.Println(" I have lost network")
		Is_master = false
		Single_mode = true


	} else {
		fmt.Println("I am a slave.")
		Is_master = false
	}
}

func Network_handler(change_in_network_chan chan bool) {

	local_ip, _ := localip.LocalIP()
	var id string
	flag.StringVar(&id, "id", "", "id of this peer")
	flag.Parse()
	var new_info peers.PeerUpdate
	if id == "" {
		local_ip, err := Local_ip
		if err != nil {
			fmt.Println(err)
			local_ip = "Disconnected."
		}
		id = fmt.Sprintf(local_ip)

		Local_ip,_ := strconv.Atoi(localip[12:])

		peer_update_chan := make(chan peers.PeerUpdate)
		peer_transmit_enable_chan := make(chan bool)

		go peers.Transmitter(20243, id, peer_transmit_enable_chan)
		go peers.Receiver(20243, peer_update_chan)
		for {
			select {
			case new_info_catcher := <-peer_update_chan:
				change_in_network_chan <- true
				new_info = new_info_catcher

				fmt.Printf("Peer update:\n")
				fmt.Printf("  Peers:    %q\n", new_info.Peers)
				fmt.Printf("  New:      %q\n", new_info.New)
				fmt.Printf("  Lost:     %q\n", new_info.Lost)



				for i:= 0 ; i < len(new_info.Peers) ; i ++ {
					str_ip := new_info.Peers[i]
					int_ip,_ := strconv.Atoi(str_ip[12:])
					Online_elev[i] = int_ip
				}
				if len(new_info.Peers) == 2{
					Online_elev[2] = -1
				}
				if len(new_info.Peers) == 1 {
					Online_elev[2] =-1
					Online_elev[1] = -1
				}
				if len(new_info.Peers) == 0 {
					Online_elev[2] =-1
					Online_elev[1] = -1
					Online_elev[0] = -1
				}
				Choose_master()
			}
		}
	}
}

func Network_setup(new_order_bool_chan chan bool) {
	var receive_port, broadcast_port int

	master_sender := make(chan Master_msg)
	master_receiver := make(chan Slave_msg)
	slave_sender := make(chan Slave_msg)
	slave_receiver := make(chan Master_msg)

	if Is_master {
		fmt.Println("Connecting as the master.")
		receive_port = slave_port
		broadcast_port = master_port

		go bcast.Transmitter(broadcast_port, master_sender)
		go bcast.Receiver(receive_port, master_receiver)
		go master_transmit()

		for {
			select {
			case catch_msg_from_slave := <-master_receiver:
				fmt.Println("Master received : ", catch_msg_from_slave)
				queue.Master_msg_handler(catch_msg_from_slave)
			case <- change_in_network_chan:

			}
		}
	} else {
		fmt.Println("Connecting as a slave.")
		receive_port = master_port
		broadcast_port = slave_port

		go bcast.Transmitter(broadcast_port, slave_sender)
		go bcast.Receiver(receive_port, slave_receiver)
		go slave_transmit()

		for {
			select {
			case catch_msg_from_master := <-slave_receiver:
				fmt.Println("Slave received : ", catch_msg_from_master)
				queue.Slave_msg_handler(catch_msg_from_master, new_order_bool_chan)
			case <- change_in_network_chan:
				//Choose_master()
			}
		}
	}
}

func master_transmit(){
	var msg Master_msg
	for {
		master_msg_to_send.Address = Local_ip
		master_msg_to_send.Global_list = queue.Global_order_list
		master_sender <- master_msg_to_send
		fmt.Println("Master sent the global list: ", master_msg_to_send.Global_list)
		time.Sleep(1 * time.Second)
	}
}

func slave_transmit(){
	var msg Slave_msg
	for {
		slave_msg_to_send.Address = Local_ip
		slave_msg_to_send.Internal_list = queue.Internal_order_list
		slave_msg_to_send.External_list = queue.External_order_list
		slave_msg_to_send.Elevator_info = queue.Elev_info
		slave_sender <- slave_msg_to_send
		fmt.Println("Slave sent the lists: ", )
		time.Sleep(1 * time.Second)
	}
}
